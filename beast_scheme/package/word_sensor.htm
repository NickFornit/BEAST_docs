<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Детектор символов, слов и фраз</title>
  <link rel="stylesheet" href="sys/common.css">
</head>
<body style="margin-left:20px;font-family:arial;font-size:14px;width:1000px;">
<div style="position:relative;height:20px;margin-bottom:20px;">
<a href="../index.htm"><img src="../img/home.png" style="position:absolute;top:0;left:0;" title="На главную."></a>
<h1 style='position:absolute;top:-10px;left:50%;transform: translate(-50%, 0);font-size:18px;'>Детектор символов, слов и фраз</h1>
</div>

Распознаватель слов и фраз по типу зоны Вернике в мозге.<br>

Для распознавания слов используется дерево слов, ветки которого состоят из символов слова.<br>
Для распознавания фраз используется дерево фраз, ветки которого состоят из отдельных распознанных слов.<br>
Память о воспринятых фразах в текущем активном контексте (Vernike_detector.go): var MemoryDetectedArr []MemoryDetected<br>

Распознавание фраз начинается в main.go с word_sensor.VerbalDetection(text_dlg, is_input_rejim, moodID)<br>
С ПУльта приходит текст, который в VerbalDetection() разбирается на фрзацы (\r\n):<br>

абзацы в PhraseSeparator() разбираются на фразы по разделителям (знаки препинания)
фразы в WordDetection() разбиваются на слова.
Распознанные (и нераспознанные) последовательности сохраняются в оперативной памяти Beast MemoryDetectedArr, где распознанный текст представлен в виде уникального laslID фразы<br>

ОПИСКИ при вводе слова. Если слово не распознается и оно имеет более 3-х символов,
то делается предположение об описке внутренних символов
(в природном распознавателе слово узнается если точно совпали первая и последняя буквы,
а внутренние буквы могут быть как угодно перемешаны)<br>
Если слово распознается, то подставляется ID слова.<br>

Тон фразы можно задать 1) с помощью знаков ! и ? в конце фразы
или задать преимущественно - выбрав Тон под окном ввода фразы.


<br>
<br>  
<li><a href="../funcs/SetNewTextBlock.htm">SetNewTextBlock</a> - Новая порция текста для формирования дерева слов</li>
<li><a href="../funcs/addNewtempArr.htm">addNewtempArr</a> - добавляются как целиком фраза, так и все слова во фразе. Тут же дозаполняетс дерево слов уже многократно провторяющимися элементами.</li>
<li><a href="../funcs/createNewNodeWordTree.htm">createNewNodeWordTree</a> - создать новый узел дерева слов</li>
<li><a href="../funcs/loadWordTree.htm">loadWordTree</a> - загрузить дерево слов  из файла</li>
<li><a href="../funcs/SaveWordTree.htm">SaveWordTree</a> - сохранить дерево слов</li>
<li><a href="../funcs/SetNewWordTreeNode.htm">SetNewWordTreeNode</a> - вставить новое слово в дерево слов</li>
<li><a href="../funcs/WordDetection.htm">WordDetection</a> - распознаватель слова</li>
<li><a href="../funcs/getAlternative.htm">getAlternative</a> - попробовать найти подходящее слово с альтрнативным ID. Первые буквы должны совпадать, а остальные, кроме последней (разные окончания),
быть перемешаны, но в наличии >80%</li>
<li><a href="../funcs/addNewMemoryDetected.htm">addNewMemoryDetected</a> - добавить строку в массив памяти о воспринятых фразах в текущем активном контексте</li>
<li><a href="../funcs/VerbalDetection.htm">VerbalDetection</a> - распознаватель образов фраз</li>
<li><a href="../funcs/updateWordTreeFromTempArr.htm">updateWordTreeFromTempArr</a> - переносим в дерево слов достаточно повторяющиеся</li>
<li><a href="../funcs/createNewNodePhraseTree.htm">createNewNodePhraseTree</a> - создать новый узел дерева фраз</li>
<li><a href="../funcs/loadPhraseTree.htm">loadPhraseTree</a> - Загрузка дерева фраз из файла</li>
<li><a href="../funcs/SavePhraseTree.htm">SavePhraseTree</a> - Сохранить дерево фраз</li>
<li><a href="../funcs/SetNewPhraseTreeNode.htm">SetNewPhraseTreeNode</a> - вставка новой фразы со вставкой новых слов фразы, так что фраза будет распознанна всегда.</li>
<li><a href="../funcs/PhraseDetection.htm">PhraseDetection</a> - проход одной фразы - распознавание ID слов фразы</li>
<li><a href="../funcs/GetPhraseStringsFromPhraseID.htm">GetPhraseStringsFromPhraseID</a> - строка из ID фразы дерева фраз</li>
